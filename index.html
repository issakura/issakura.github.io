<!DOCTYPE html>
<html lang="zh">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Image Slider</title>
  <script src="https://cdn.jsdelivr.net/npm/siema@1.5.1/dist/siema.min.js"></script>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      width: 100%;
      min-height: 100vh;
      background: linear-gradient(135deg, #f5f7fa 0%, #c3cfe2 100%);
      display: flex;
      flex-direction: column;
      align-items: center;
      padding: 2rem 1rem;
      text-align: center;
    }

    h1 {
      font-size: 2rem;
      color: #4a90e2;
      margin-bottom: 1rem;
    }

    .slider-container {
      width: 100%;
      max-width: 800px;
      margin: 2rem auto;
      border-radius: 10px;
      overflow: hidden;
    }

    .siema img {
      width: 100%;
      height: auto;
      display: block;
    }

    .hint {
      margin-top: 1rem;
      font-size: 1.2rem;
      color: #4a90e2;
      opacity: 0.7;
    }
    .vertical-section {
      margin-top: 2rem;
    }
    @media (max-width: 768px) {
      .slider-container {
        max-width: 100%;
      }
    @media (max-width: 480px) {
      body {
        padding: 1rem 0.5rem;
      }

      h1 {
        font-size: 1.5rem;
      }
      .hint {
        font-size: 1rem;
      }
    }
  </style>
</head>
<body>
  <h1>Sakura's JK Collection </h1>
  <div class="hint">
    <p>Swiping the picture to switch</p>
  </div>
  <div class="slider-container">
    <div class="siema">
      <img src="https://hv.z.wiki/autoupload/20241223/EWiF/5840X3893/%E3%80%90%E5%93%B2%E9%A3%8E%E5%A3%81%E7%BA%B8%E3%80%91%E5%88%B6%E6%9C%8D-%E5%B0%91%E5%A5%B3.png" alt="l">
         <img src="https://cdn.10086.click/show/2024-12-26/4e317ede-b55c-4d11-a4a6-5799e10eea10.jpg" alt="i">
      <img src="https://cdn.10086.click/show/2024-12-26/346492a0-c6f1-4052-be62-250fe96f08fe.jpg" alt="k">
      <img src="https://cdn.10086.click/show/2024-12-26/835505e5-e3f1-4503-8f68-ec740fe8a432.jpg" alt="e">
      <img src="https://cdn.10086.click/show/2024-12-26/a97a559e-c5d2-404a-9273-11bbb453bf6c.jpg" alt="H">
        <img src="https://cdn.10086.click/show/2024-12-26/1227435a-f7a0-48bf-9624-034d5d9dac26.jpg" alt="H0">
           <img src="https://cdn.10086.click/show/2024-12-26/2e1cfd14-772d-4641-9bb3-1925e9295a02.jpg" alt="H2">
<img src="https://cdn.10086.click/show/2024-12-26/7f8cf05b-051d-4d4c-975f-4ed66f4fc8c8.jpg" alt="Image">
<img src="https://cdn.10086.click/show/2024-12-26/d6e2b698-976f-45c6-958a-221f62f74fb0.jpg" alt="Image">
<img src="https://cdn.10086.click/show/2024-12-26/50226a13-f682-4c9c-9247-880c88825292.jpg" alt="Image">
<img src="https://cdn.10086.click/show/2024-12-26/617baa1f-e85f-4d88-b715-64f53ad2e8b0.jpg" alt="Image">
<img src="https://cdn.10086.click/show/2024-12-26/b2454b31-4336-471d-9ea4-58d6b16ca740.jpg" alt="Image">
<img src="https://cdn.10086.click/show/2024-12-26/f0a608f5-fafc-4eb1-b2e4-12905c365d5b.jpg" alt="Image">
<img src="https://cdn.10086.click/show/2024-12-26/d5c76c92-c71f-426c-9161-2bef03d60f09.jpg" alt="Image">
<img src="https://cdn.10086.click/show/2024-12-26/11973c63-15cc-4dd8-aa9d-d2ea38ab212f.jpg" alt="Image">
<img src="https://cdn.10086.click/show/2024-12-26/d37089dd-b6b4-4bb2-98d3-36d99d857e3d.jpg" alt="Image">
<img src="https://cdn.10086.click/show/2024-12-26/a118fb91-1638-4298-b463-52e85ad1831d.jpg" alt="Image">
<img src="https://cdn.10086.click/show/2024-12-26/91f4e1b4-ab45-445e-9fac-c5eb45d2b8d4.jpg" alt="Image">
<img src="https://cdn.10086.click/show/2024-12-26/9619c78a-76a6-4689-adbc-c7f766bf25d0.jpg" alt="Image">
<img src="https://cdn.10086.click/show/2024-12-26/f851162e-0ff7-44c9-9449-dba649adee0c.jpg" alt="Image">
<img src="https://cdn.10086.click/show/2024-12-26/56510c1a-203e-4cd4-9748-c404093e2ebc.jpg" alt="Image">
<img src="https://cdn.10086.click/show/2024-12-26/d9749ce5-4a26-4602-9cd7-62614dca3e8b.jpg" alt="Image">
<img src="https://cdn.10086.click/show/2024-12-26/72f35dca-fc6e-4c3a-b385-d076cd610218.jpg" alt="Image">
<img src="https://cdn.10086.click/show/2024-12-26/6a26ef3c-70fe-427d-bd49-9da999d706e4.jpg" alt="Image">
<img src="https://cdn.10086.click/show/2024-12-26/d5308ca7-d44e-46bc-be03-d5cb8ba8bdb3.jpg" alt="Image">
<img src="https://cdn.10086.click/show/2024-12-26/7931fd84-6e7a-4f2a-b720-a6d4230ca71d.jpg" alt="Image">
<img src="https://cdn.10086.click/show/2024-12-26/b4a42bc1-464a-4836-a858-199c41a664f9.jpg" alt="Image">
<img src="https://cdn.10086.click/show/2024-12-26/b8af1dfc-a6e7-49b3-ae57-d48777ccaff1.jpg" alt="Image">

                        
                
    </div>
  </div>
  <script>
    const mySiema = new Siema({
      duration: 200,
      easing: 'ease-out',
      perPage: 1,
      startIndex: 0,
      draggable: true,
      threshold: 20,
      loop: true,
    });
    // these variables will be filled when generating the file - the template format is 'variable_name'
const staticryptInitiator = ((function () {
  const exports = {};
  const cryptoEngine = ((function () {
    const exports = {};
    const { subtle } = crypto;
    const IV_BITS = 16 * 8;
    const HEX_BITS = 4;
    const ENCRYPTION_ALGO = "AES-CBC";

    /**
     * Translates between utf8 encoded hexadecimal strings
     * and Uint8Array bytes.
     */
    const HexEncoder = {
      /**
       * hex string -> bytes
       * @param {string} hexString
       * @returns {Uint8Array}
       */
      parse: function (hexString) {
        if (hexString.length % 2!== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);
        for (let i = 0; i < hexString.length; i += 2) {
          const byteValue = parseInt(hexString.substring(i, i + 2), 16);
          if (isNaN(byteValue)) {
            throw "Invalid hexString";
          }
          arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
      },
      /**
       * bytes -> hex string
       * @param {Uint8Array} bytes
       * @returns {string}
       */
      stringify: function (bytes) {
        const hexBytes = [];
        for (let i = 0; i < bytes.length; ++i) {
          let byteString = bytes[i].toString(16);
          if (byteString.length < 2) {
            byteString = "0" + byteString;
          }
          hexBytes.push(byteString);
        }
        return hexBytes.join("");
      },
    };

    /**
     * Translates between utf8 strings and Uint8Array bytes.
     */
    const UTF8Encoder = {
      parse: function (str) {
        return new TextEncoder().encode(str);
      },
      stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
      },
    };

    /**
     * Salt and encrypt a msg with a password.
     */
    async function encrypt(msg, hashedPassword) {
      // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
      // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
      const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));
      const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);
      const encrypted = await subtle.encrypt(
        {
          name: ENCRYPTION_ALGO,
          iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
      );
      // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
      return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
    }
    exports.encrypt = encrypt;

    /**
     * Decrypt a salted msg using a password.
     *
     * @param {string} encryptedMsg
     * @param {string} hashedPassword
     * @returns {Promise<string>}
     */
    async function decrypt(encryptedMsg, hashedPassword) {
      const ivLength = IV_BITS / HEX_BITS;
      const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
      const encrypted = encryptedMsg.substring(ivLength);
      const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);
      const outBuffer = await subtle.decrypt(
        {
          name: ENCRYPTION_ALGO,
          iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
      );
      return UTF8Encoder.stringify(new Uint8Array(outBuffer));
    }
    exports.decrypt = decrypt;

    /**
     * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
     *
     * @param {string} password
     * @param {string} salt
     * @returns {Promise<string>}
     */
    async function hashPassword(password, salt) {
      // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
      // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
      let hashedPassword = await hashLegacyRound(password, salt);
      hashedPassword = await hashSecondRound(hashedPassword, salt);
      return hashThirdRound(hashedPassword, salt);
    }
    exports.hashPassword = hashPassword;

    /**
     * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
     * compatibility.
     *
     * @param {string} password
     * @param {string} salt
     * @returns {Promise<string>}
     */
    function hashLegacyRound(password, salt) {
      return pbkdf2(password, salt, 1000, "SHA-1");
    }
    exports.hashLegacyRound = hashLegacyRound;

    /**
     * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
     * remember-me/autodecrypt links, we need to support going from that to more iterations.
     *
     * @param hashedPassword
     * @param salt
     * @returns {Promise<string>}
     */
    function hashSecondRound(hashedPassword, salt) {
      return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
    }
    exports.hashSecondRound = hashSecondRound;

    /**
     * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
     * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
     *
     * @param hashedPassword
     * @param salt
     * @returns {Promise<string>}
     */
    function hashThirdRound(hashedPassword, salt) {
      return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
    }
    exports.hashThirdRound = hashThirdRound;

    /**
     * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
     *
     * @param {string} password
     * @param {string} salt
     * @param {int} iterations
     * @param {string} hashAlgorithm
     * @returns {Promise<string>}
     */
    async function pbkdf2(password, salt, iterations, hashAlgorithm) {
      const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);
      const keyBytes = await subtle.deriveBits(
        {
          name: "PBKDF2",
          hash: hashAlgorithm,
          iterations,
          salt: UTF8Encoder.parse(salt),
        },
        key,
        256
      );
      return HexEncoder.stringify(new Uint8Array(keyBytes));
    }

    function generateRandomSalt() {
      const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));
      return HexEncoder.stringify(new Uint8Array(bytes));
    }
    exports.generateRandomSalt = generateRandomSalt;

    async function signMessage(hashedPassword, message) {
      const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
          name: "HMAC",
          hash: "SHA-256",
        },
        false,
        ["sign"]
      );
      const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));
      return HexEncoder.stringify(new Uint8Array(signature));
    }
    exports.signMessage = signMessage;

    function getRandomAlphanum() {
      const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";
      let byteArray;
      let parsedInt;
      // Keep generating new random bytes until we get a value that falls
      // within a range that can be evenly divided by possibleCharacters.length
      do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
      } while (parsedInt >= 256 - (256 % possibleCharacters.length));
      // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
      const randomIndex = parsedInt % possibleCharacters.length;
      return possibleCharacters[randomIndex];
    }

    /**
     * Generate a random string of a given length.
     *
     * @param {int} length
     * @returns {string}
     */
    function generateRandomString(length) {
      let randomString = "";
      for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
      }
      return randomString;
    }
    exports.generateRandomString = generateRandomString;

    return exports;
  })());

  const codec = ((function () {
    const exports = {};

    /**
     * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
     *
     * @param cryptoEngine - the engine to use for encryption / decryption
     */
    function init(cryptoEngine) {
      const exports = {};

      /**
       * Top-level function for encoding a message.
       * Includes password hashing, encryption, and signing.
       *
       * @param {string} msg
       * @param {string} password
       * @param {string} salt
       *
       * @returns {string} The encoded text
       */
      async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);
        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);
        return hmac + encrypted;
      }
      exports.encode = encode;

      /**
       * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
       * we don't need to hash the password multiple times.
       *
       * @param {string} msg
       * @param {string} hashedPassword
       *
       * @returns {string} The encoded text
       */
      async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);
        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);
        return hmac + encrypted;
      }
      exports.encodeWithHashedPassword = encodeWithHashedPassword;

      /**
       * Top-level function for decoding a message.
       * Includes signature check and decryption.
       *
       * @param {string} signedMsg
       * @param {string} hashedPassword
       * @param {string} salt
       * @param {int} backwardCompatibleAttempt
       * @param {string} originalPassword
       *
       * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
       */
      async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);
        if (decryptedHMAC!== encryptedHMAC) {
          // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
          // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
          originalPassword = originalPassword || hashedPassword;
          if (backwardCompatibleAttempt === 0) {
            const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);
            return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
          }
          if (backwardCompatibleAttempt === 1) {
            let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
            updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);
            return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
          }
          return { success: false, message: "Signature mismatch" };
        }
        return {
          success: true,
          decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
      }
      exports.decode = decode;

      return exports;
    }
    exports.init = init;

    return exports;
  })());

  const decode = codec.init(cryptoEngine).decode;

  /**
   * Initialize the staticrypt module, that exposes functions callbable by the password_template.
   *
   * @param {{
   *  staticryptEncryptedMsgUniqueVariableName: string,
   *  isRememberEnabled: boolean,
   *  rememberDurationInDays: number,
   *  staticryptSaltUniqueVariableName: string,
   * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
   *
   * @param {{
   *  rememberExpirationKey: string,
   *  rememberPassphraseKey: string,
   *  replaceHtmlCallback: function,
   *  clearLocalStorageCallback: function,
   * }} templateConfig - object of data that can be configured by a custom password_template.
   */
  function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
      const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
      const { replaceHtmlCallback } = templateConfig;
      const result = await decode(
        staticryptEncryptedMsgUniqueVariableName,
        hashedPassword,
        staticryptSaltUniqueVariableName
      );
      if (!result.success) {
        return false;
      }
      const plainHTML = result.decoded;
      // if the user configured a callback call it, otherwise just replace the whole HTML
      if (typeof replaceHtmlCallback === "function") {
        replaceHtmlCallback(plainHTML);
      } else {
        document.write(plainHTML);
        document.close();
      }
      return true;
    }
    exports.decryptAndReplaceHtml = decryptAndReplaceHtml;

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
      const { staticryptSaltUniqueVariableName } = staticryptConfig;
      // decrypt and replace the whole page
      const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
      return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
      const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
      const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;
      const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);
      if (!isDecryptionSuccessful) {
        return {
          isSuccessful: false,
          hashedPassword,
        };
      }
      // remember the hashedPassword and set its expiration if necessary
      if (isRememberEnabled && isRememberChecked) {
        window.localStorage.setItem(rememberPassphraseKey, hashedPassword);
        // set the expiration if the duration isn't 0 (meaning no expiration)
  </script>
</body>
</html>