<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }

            @media screen and (-webkit-min-device-pixel-ratio: 0) {
                .staticrypt-form input[type="password"],
                input[type="text"] {
                    font-size: 16px;
                }
            }
        </style>
    <script type="text/javascript" nonce="6ae04ede709944f2be5c5ba72a6" src="//injections.adguard.org?ts=1737387569382&amp;type=content-script&amp;dmn=robinmoisson.github.io&amp;url=https%3A%2F%2Frobinmoisson.github.io%2Fstaticrypt%2Flib%2Fpassword_template.html&amp;app=chrome.exe&amp;css=3&amp;js=1&amp;rel=1&amp;rji=1&amp;sbe=1&amp;stealth=1&amp;st-dnt"></script>
<script type="text/javascript" nonce="6ae04ede709944f2be5c5ba72a6" src="//injections.adguard.org?ts=1737387569382&amp;name=AdGuard%20Assistant&amp;name=AdGuard%20Extra&amp;name=AdGuard%20Popup%20Blocker&amp;name=Web%20of%20Trust&amp;type=user-script"></script></head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="template_toggle_show"
                                title="template_toggle_show"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = 
            ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
        ;
            const templateError = "template_error",
                templateToggleAltShow = "template_toggle_show",
                templateToggleAltHide = "template_toggle_hide",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"61777c285c5de9749a588ed34d8ec5fe0dfa1be1c536d16590c72675ba17175e09533c181930535a80cd0bae5baedd408a65681569c3cedcaf4e36467d8e7d0a66a9585091470c9761e52984ae3eaa42421552685c63ed18d323758b14a663e2b9eb89ee8ef117fcc2ef0b1227cf8a1256c494eb493999e2c84736b25b66caa542e88793e7c173091668b25cd94727fefd53102f5a443b78d7e79193ce0da547d12e87195344abfd6c1dd319f3f2be519331adba93df0eb6ecd78c1a580aff0b92cc7b2c592a0d2ec3a9d1565f325fe8577fc27f8e5497cd44c0a04be17ae51688f0e5f0abb777ea91c7d469a97b897bca4bb1813c3ecaf7042a2a086e1094b20a3a2400a0f37b75e6339c3aa9d58020e100460b534511307e0c6d7b0aac2438e73d630055d90a621f609c70b38f66e57e564538852e001547ea253b453a8ae34104c706eaa390bb34feb2addbb7aec6242a712aa0f82bc63bd576eefc4699717ba5d29e42e0598f126b601a849643b962fc6c0e51af2fbfb11808c46ec11cdd45abd57c55a6e397b3393a468883e39194776427cace36aa4948d8b4f59827c75a3517f18428d1a73cb2a880bef608c7fff618e2b286a53b3b50d05db23509b0daaae1977c4041e747b9e5f6197b221d1fa950b8ee4c3b8a588aa37fc552be9d80e9167aabcdf69649be22c4c673076876438c253881f34c76b1cd78aca82394af241394e343cf8dc5619c8cb09870ae21c37c0486241edafeec183b86e928312dfc045877b11523afc1c906f52cb8c92abbf704405805deb33a89e4bce51b623b0913503413e354873cbc396a5d11876234646d6f82f2e003d3be9543e6f7face73f2df7214919335c44e7c6fc10274bd882d844371f3d27407a07148dd8d4459aeaaa7cc68c6c10d9ef0c8c91ab1728378a33d8891015073ebdd86a06bdcd9acf50d853bd1951a220c04110a288e8382d675e808f52a7d42832f597a137e94537db8e87aa130c2e957f66ba1d66bff8ddf1633acf7fbefa61a30ac16699b41a809d60e0483454acd049e6161aa6ab5b46fb0a42167c788a02416dfc78a0077a7ee11b46c036375caec47455d33d56b9504e766eb02aa5d8db15a63b47bc692252d9ddb7ff599c244a965ba66e0a5fe5d4acb84942f42b72feba7f0128832c7dd91ca6707896d71294574263e5da229990c05b0e59b596a55bdbd0ed7089c42b0c5f5598872be5eb2b8b8d331e31cbb0b5896082d004cf9ad3528a4f35934f8440a9ab2c0bf1871c6320e8b916378d1d028c4723c49c3dcdc03dcb5b308f047dfac42f2c99f0b2ea56864c9d0868c779140fc4a33c24f5cba07d3da5b0e391e01752bfcf379d9c7b993c32ff75194d6c3377c1a63381482be9fe342f7d95250962eeab4b75f501abfed86970982f095991522da1689a097a855affd2ad6fd7748fed341666bf1c122eae2a7bf1337595423fbd9cf03b253edd7a7ede19bc697470a44c287277ea1c5a7d1fad526b8e83ab015e0aa3fade8909256ee15088eec4c3d9772e67bb1e9956b69e7e8f0d206e7679f6c406503bf143fe95c8d721f876f9ce4a275fe30a9c2e44871f5162744da05fdc1c03d1697cda8e43888742c39034effb625239f8f2445749fc07907e24782114b4747a9eaad61b094e508128406864248f7fb68a98c6a147106966537998a09fc4022780fa50a83917c16cad4114fa86ef90298c62bc674675c1f058e4e11249fd2d9870cdde2d8f4c25b55ba1300cdb42bd3209bb2b7b6b1a8a98035a4d9749242087b205f5c563bb47f5c60c0e174e5900d55906169dea7b1cb541a3d824f3454d110fb9ae04dd323b36993c855e0d7af74787019a3c7050a32a12b488b301353fc3286d1251708d72f1048af6c4f28a17ed67ed551651d3a8772e38e8fa7a35b5d1b4d1346a95ed2538b2ee55bff40ec130349d51b0c441d9293d645abb00722817197d015df2f8391ce0b6e1fe14fe824519b7fdac4b2e3b7bec4d3999c99264ba6691deaa8841e57b6da3898d855ee74e6a53b28571ecea6fc3f2ee31b29c895471263c10bfe46c70d11510704868f2c289775dafb2e7b627e685475e9eda5988ae80d2151209387085d15df2610e40031f491bb40f953237594602cca0037d46afdb3fb5749780fc4ad2ddbd94bcb8904b217793a46148974fadc26d32ec15c554c732143e1753279791db8666fb93de41e0d24dcd1f6d39e8a847d927a7c3cc74cde32ea8bd5bc0a39c57b8687d6315ac1c04aef2e2bc09b68ef455a7bdbfe24224d15b2e03daf0ca8d007c66fcf356e96981e560f0dee83c371d81d8d4c8d0f3f771c3e748b117c8129be467d4ff3533afc50d711167bc4c5e26fe78a264dd1cd6a3cc4d51c82d675bc61fc02972c6e2055f414741d40800b4615ac4a5c9da70c64cf408efc2e124f2f81712012d0ae869294509febb2e55d73346d4a0c684f54f240b0880a28ff6fc40dbca2650b171207e6ef983430e5a3204e97004e41e31f916899de8bf2df971edb0b2346452202712dc619e07356ceb631523decaf47e01195e89c68f5523eeb9a19a60cf2dfc28aa385ff257517c27c4f40249396301309a298e306065f6796e4552923f8606cb52bfe6373bedacf265c8223ddd8c9293b92d84378bfb1b4de76dd48aec7851a3458e70cc9855f134c0e526b451031091e4820395e2d1c783aabdde289d2d43abab1b2e86dc550d14d8337347e0755b2fd99042cd1f80f799e40095904f56ca13a11ade35699985713a37e60488e3666fdc1a808013d090fa71edae2311df77505197105454d79a0fda8e18858f822f0218b7d4c2cce251ddc103d33738b22ddd0ac42e5645a1c87de84e064e12fd7a2cfcc12f04ae7a0c24bd18b31b5bc964da148689b74b34efe7c8ca94713ca2cb0780087b3cfb81d6cdc01c5a5f631fb84802a70fc03b6bbfdc974febae77ba6c56fa21bbc949f41f6d781a61ac34d23bafb273a240aef58d3380d70a53f108dce783ce204c3ea0ed4aebb03ec08a533054b60ceac59728dc6b9bf759b68653f022a692ec5e2cab76ae1b79c47e19a278e0ee45944abf03880d32ddb37fae35b72f58d55c648337580385cbb187db918128bfebb5485262b178a5973e115b6afc8b0ddc932d6be77258439431cf9159550b334d4d66dba85bc72fb54fa2a1b9a6d4b21e182a5b23e7fb0f7ea966c7c116592c43591f83bf8d92eca333886f0b09c7af0c3e4eaa963b6a5d3799825a67623e0898a25b1311ecdc9a9c36c22e946c9575c3e7b78b186dc7844455630419b9cc286a5ea6211cbfc39724891f83ab6e16db8fd9ea038eb9b1c4d24b0f2840abf430811b6344cad99851f4472ab12868995d991072eb0f0e2430f96ab5484dd8592c145ea947ab75937b78f82a2ddb7488447356482651367884a01a4e9151537be08774037ba80f7c6b324846b896c89f4100a2eef88b3fde666c2411e17b161c391466ee67c7423fd82ab92de3e6ab5cfe5b18f01da8019d272f7e8064d3339d465bc9b6e8c7eecb5accbeb441a53fe9a3b78a73f3e198ac896d161c6b0065ee5a835e429744d21a4fe4743a4fc4e59f9bd03500d24a4bfa4afba05fc585a5be0e9cb407bf116e9f05b753b39b25caf43ab97e84a7d035d578f251b2ae8ccb42ff8a73de56eb3407f3a648acedc1c5323af1c343661aa69150c5ea5ebb5e124ebad6e4fc6dd91623d2a57db548e447f1c052dd86b66e8ce6829e5eb3bcc2ced19751cf41d5cce61c736abac82af31756187c3c4044968b429c809af263ef58e0ea715041c4dc02baf6ad7b39179176e8b13b0388bfdd39415812e31bd785373e5f8bd98a91fc6a7cb6db716b464ef2db2c02db39f49779828d496d81ffebb6681bba4bd1bc3e912fb789857308c4146f2fb762b80fcc367d4eb86a206d1c4593dc90b051407dc58dad432c38501433040061493a40f00c3435d3c1ae6400779f4059e7bee4b6ca5c58070f170526c351856523fcf985f38dd209e6241c002eecca71bf8649056aeac4e9e49908a97961d9cd4e2f410838cd5c23643715a33ccd0da23b2b6303c765b6d2e0f4e629c97ac56191a4463923670f21791e866958c54a6581c908f49c1d982a6a8159700bceb7e50cfc56721080188ad09f7b12e9bf87a75ffc3a7b2ac44d9bf060b5063dfdb2166d5343161dbcdb746c12cecdfea86065f0caa1d8e67fcc45cae3b2a69ebfd33ac006ccc73ad81f2d12d8ac58f8bc9d78a9da4954aaa3faa64e1bf5d17dcc4b43319037e9932b9fa0339b26b226828838dd476591377b4257e3de0695e53ab0f47bdbdd852dd5a73bdfbc9e04566a217ebd884aa98ffc9cb7c0ba367e59a5890eb1eccea3e7fe727d963981a0bb01503019162d58cf0f7f793252ab347855063fac8d8556b6e1a42727e495fb9b3003f27e0b604c92c0512342775c33c8a6e0b7f47f16bef8d9a8a53c3e5d10ad46c00af2ac09e07929c6147ebf6de44d76eb043d7b8f15ce6298efa8ff6ec7fefa1c6ee6ee3df72aaacd374e0b74842b93f667b89d55b6609b6841ef888df85a590b92b25c7b92d33e2f83ace0fb1b9fcc0357dab3636bf987de2ecb0c660b93a4d33c0870a44468bc0ef1ab12770eab70b97b4e3828816f573603950fa558573800705212bff9ac1b64e4ab9d2de6b002617d6881dc40f6df33edad6140e0c372a21050bb85a6f426cf5d60124aec7e442f082e2789dbb5ce4b0219f3424dda43ff4cd2637ea6ed64ce7fca41760d0c22aee1627e369c486f96c0c847f907d3f3f3563670205d5055232d8d7574ef523b04c729a87e242ee1ebfad7e561a64e987f7d86a599d317c0127993726c381f27cf9bbdad16b355d4b5182d8b7ca9934f7b61fde13943ad051651fc2d6a39c2a4e9910e30c740369166e3440ce83160347498700f6008e20c1ce07818713adf3c6182f2fc53900baeaf723ab4cb4ffff4d565197ebca0c78d362fd5ad11f58ed344bba7fc90f065f24783ec8029f2645b0549e9dc8488950a5a7daa560191914414186f19e8bb21ec4740c56e7fae70bcd2ff186d0e1acb3117646d3b45c09c2ef506b7dea25b56d0074e2e985243beca6ac51d650b5d2074e3e72408abb52704fe2dd0383e42acc1b05f6c85b6b02486c591974c6f121820f5f87af91964a80795ac4d52b873b63f64c62d7ac45b11993de42bddb82bc215d20cd99caf788d7d67669645e4946c48912ed5d804630b08ba6116a8708be2aa803bcfe4f7bb24bc8785542cbb3e2675cd4c25f87eb5351ac1a336ce3381e473a2afa26b754246d6cc38e766bfb4c555c5b609760f5ddb9fb450e18fa57bca8dc2b483fe1612e276da1381de4d34f0ff7bbf162b7aedf50469d1e82f30c44ccef930a2e54f54eaf87da7187063a93ef78afe67c4c885d43d71b2f76d097d023e5eb36a31f55e45fadb8b1d22a5bfeab2f6a54bc78c9a846f173c2b3149591bb3b4f8b787a76f92f7bbe24ce304bc596dd6d52b4f22c8f94b89adfd0cac7b911e971e9fc4743f73788ec84c0be73f27a7271e85c12c50efd8a43eb8724bdd7a947772598fcc712db339dcc397451f73a27b3c0af1686d300348a9b773f14647d9aea9036e99b351e424ca3de63d567eb2316e56e1225076c75956c7206b409c1b77371c235d01934f74054d096d868a4ced273d787e484d60d198e8555277ae304b069a7c5b37eb69a6ed385010ed2f1d36049cbc8be15292c68caaef6d727407bbba4383503d77b34ab282145b0427f479d30e19e99d3b795bd36f89ff332549f5124a17484628dfbb82e7cc19bab9ee226bcfad76fdadd4d7cf97c0df620c63123a861b106a93d36eba1cdd7edf58b8709f952dec3f3f588d7fd41547f023b69915ac5d5121f6cab160755be62e9fed601eb12e05db6c36e382e5455eec195c147346b90dbafcf44d2e242d4d84d9b2d3721214b083f19daeb8f9d75d4108bb3077eb4d84645824231121499daffd685817bb9e6d40b6f34353c545500fc85275239bad903205dc22474ece57123a0eba5b7b7924563c3854a026036ee54d9c93a56082e8dcc3bc31cf6f580dee96378f5c0f3cacbf259dba397a475379117bc90afa238cffb3cb31ed4216bdedf5cfc4120bcb1f0b8bf1a57ebe170808116add77eba70d1b97b244ac2f6f49f67cd9a9fb207f821e312020056b03293c0e64e257dbbd029b69c11cc3ebb038a6fb3d4424c1983ccf688abbdd3d9a4d532e50c66c01e539f155fb02ff3555a225aa87ad75f2fa4e16d65b68a412802d68922e19e54581a76b55040ef9b312dc03f7dc0a9ba0ce00149e1f83af2c6b6975ce1ba370150daa54d2f2d566c743fe7abfd8baf5d69048548ea600bc43383aacbafa564f4fd00ffef3cfe00bf5459601f2a2f00966470f20d82a40c4634c30218ea30c9823b5564c9d0737ee95bab2a2c06a11307a922f62b6347cafa4b7f639aaef29ca3de20d7c742db857c2df26cff34a04d37d0d6787ac8199fa18f21a18be501c0e3c934f36253be8614a4b7e64a32d80b9b507958d7957fba8183750e3af9aeddb24b43c28278ae8bef756a7c4ed4e80294230e143245df1f5d7a4e33790d71353bd600a0c118b53762fdc31c0a45566b4039610ae226fadefedc601b095c641a50939a2816fa2372f8ff4be58810d5564b3e51cd13393f394d28e3369101499c48d463ca79f83ad66d2e533c4a44d57905b6bedc9b7d528aa42166f482235d3b45aea8af2ba8da62a369e4394e9803433ee5669669de81ba1824f0a78f3c1d2333a4e55a3d28e073dc66adc704d1f089da93f4dfbe7107340139ded3441947de0cf603a229321c6f8a37858b67127a24c5ac680b86c46fbd27a72b4cd2341bd0449332aa84647ed992abf738d989d7272c27800e1762fd2ce2d04d40c646797b9f683dccae5c1856c49c2c73c1b99d522bdc573fcf094d998e140a9f45722d6dd943c91abbcc765b05eaa59434c94ce3fff4a772da25f64a74253928ddf4620c1dce134459309ef37f3864c1ec1a9b2063d0c7ea604991f859641d62447e29819e638c694de2170e105ae0caa776b156195b26a67b8f877e21d294cae475f1a22848141dc8a88f134ef77e786c1ca74e723c57b434d142baa4fa267ba92580142126ac55f001542c8c62f3859c53454508ea2229f4b431f1207d87ab0a85722d3316d7f89839f3bbfd7b264ffba0311e7e99dfb4fa2f71b2726637ea3b2e4cd427a608b74d9a91ebc3872398a66ac2f76527cc731168216bc35741a0b801c8e6d9614f91a8a63c459f27466484b375d6142615567a41ff965c62e451287606827f4fc8c7876b28a60a4c69616521ef58aa4c28387b82b161249507d9b8dd5342a634bbaee2d078d428be07ca9e07f0d053f55ea84f1c5191cd4d24554b60d7daf095b515cdf6b24e76115989f217ff36b5343a3b55b5735d8c3dc0aceb4935a80506175ccae34dd09b8e23c8ea6dd0110f917c90a03209f022e72612f2a916b7991b04ab33e7279e8d3635a05a7aa8f4bc013fcbda9c23a0268af34d6281b8ed7fa49f496fadd319979e887e56446eda0d8d9962c2d75965564a036ea621b68cb4f8de833c5025e894c3eb94bb7cd5d345041f01327b8ab78b00b608c38c3cac44c26468cf4ba8180493209385267b9f1976f1360977604f44fc7d8745a527c536d38376b4cef67012ecb028c368158c18725e6a319638972222c103d55a42942e2df04c61b982a63a23cbd5883d50d89be112bff16da8e1de671942517ef7041b2ff5da06014dec893369c68961f4e24250d6879cb51ff7643180fd2c77259073ae195f8375b7ecdac9f7e8b65667da7fb01c6d0bd8d98d30663f2ef9d4ff6de1b31c0838e28d2195754d8455615a7650e255ee373e8d4af87ad87a96affa6f74a9023fa4570562eda4d9ada543d7c7efa7af24817411b5c9e7a99063f5b6b3dc77a8ecd37783d7deb6bd2d810f13ab3319b66410939d810dcdc7db68bf99b093b73dfd7bf4ccc06f222caaff1fd2abb78cada78dd6de07b81b35039c83d263f5eedb8431516af69e7b1a5dd2217300ff000dc897a63bf370aba2417d3cee40b097c171197353f6dcdba16bc8a1d468083f089c1f228795f5826beeefbb7e0215573f8ed546c0017a75c05be6b3b9ccdbef111f65f1cd2b989385877c0f3b7858a5339c0c0d7be458246125370aef07ae39d49582a5fed1b83ab3881a2d86226423ff8d29eb1dace881f10e8d3431da1baf576990f2ee498f14faa4b0ee20f1cc8a5eff1d3dfb14728eec55231477e79fc091af6a66ac76ca89bc353d478ce976fc13ef8303d663552fbd1ca0e2c524c9036d08c170abbb6ac25f426fe3b2352590f32a505e46f8412ce56aedffdca76f68bd83260dc32215cf9727832df6a2a9ef470926ad687ef21ba02599d99923d5ce698f77f761086bad14afc89391f3474f05ffe0041a7af5334805fa8bb1ae0da080a1db7947da0bb367a4f4e32128efce5b36f4385e80090e297d6d69daf463358403a17792fc55a36a129dbdcf8bf4f61b9f10f3b3f61e874b93418dab14ce5198fe7dee421fd92edc232149800cb99f920cb9a1a50fc9f9b50a67a9875668237a5f0941b70a045fe8a4302dd8def2dd2b0d9680e6523233fabee8a2489f98fe4ddbb0088f5e50f16f4de270fbfa39d003502350a23d74314c5eecc49008584c2740d52d2f95822e24395d36e730b5e34df8a3e3edfadfa2fcb56bd30e035906cbc496b9b64398746fb81b20b6aa00e3a8483c82796f0b0dc7e56f6cf0d065b423beaddbe819f52036a9c7f3cb994e91cf1bc7da8e198244014f89f6007bdfb6cacf3e48044e27f950efb0da6e46c33aa18c6286e07880380bf1c5ffb6ecec304edebe3aa40b95e9f51c9bf2d716e49fd41798ea183cae7361aa87b0f973f938d33c8fe97854bb9d316a7694bda28cd2c80c87ea4e7554750a2ebdba4a6500e04123680a71b409909ce1728fd8c748f717181fff6a19b309be48b33325166d9a5fc406e090828bf41c226050786372b46de63eeb43edf2bf3a824aa86f39a31e0405ca716ec5e21eb2ee6befe004c35f3119c909019dfb34f1022fc41dd081617b114cfd41262cb41841d45d632525c073debab5863a3d7d8a720e19f800fc5975df295c67af4e4e62f6da788f7699e896457e58ffa2aee294a456db9c72439ae6188e72f36e335bf38677e46d3272426fc4b6b573a8eea16fca4dfb11d33f47072659e6aa8b511ebba829512921c5f96d828099cdde5453400f3a94bca3c15a326671dea38c79e6c169900e83f407f26d6513af57b7cd1baad452e95e015a21e42aef7f719a419ec4e2fda8ee5a5a0d85d17796fe076dc1e9e7f88626c03c385e188b05b38417d4bee8f4b8799c44fc0204a048ae00f5d4d6fca977c78bec87d398eaacc1a88ae0384873c14b7b43bc23d0c1de5fd3cab0c1cce3e4b759544d61cf0e2a0f6bd31464a6b67d4e294064644495a95915cbf859a84739e8ef812e498e8e8948b6069d2202cc711fb698f76a6be8ba127c42bef88abd740092aad4114df1570fc076e3cbe9046395773562f7ae05ee82e1fe9fc0f59aae90eda06eb0709829991a5585333a980b5935dccbda6c277882e8126e21c8ec6010d6a8899567e4f132cc5e0c2b594a75066db3bd35d851e8c0ced98739dae80931673c090d94951256b51a374a345eb87484258aae04c8ae3726f9e04d36447033ae90c2dbf13656338998d4a0d7bf3a24aa09bcaff180d8a670adbc0424253f3a34210cb2ec97fd3938581cc79dc7ea22697600963635eb1cd3c04b0e9f51d31e4b20a2a15cac117c47280cba43a605621c2c0e6f8bba4827a061386b278f44cf8542f9c031c80449f41f96f583683c48e2bef078c0f19e41ba55b5c8fbf88a0e8f36181320b639444440ccbd169f1e28d97a87148fcbe4f9695e44c8fe1cb063edff183672fb76f44d1241ba2f3fc4c358ebb5b1fc000c53b928afcd6db94dc9db18b64591d8e7fb936b9f077b7ae24fa236644d93401835051ab5e4fab22577d6d7703492708b5df3ca0a74e21545ea098632da92839fc1c350614c1bc266a27bc90f439682d3632c7a9ca42f5647cd54320065ac7ee877c0a0e1d15650d90bb8cc8a86724862f0466f43a12fd45f6fd44719c59f2b307df03ea8dbca0ef63eb15b942821846260c89d2a33153a31975c4c73d198a02178afdb8ccbb42c50bc191ee9f71cb46465dbff94c1f0849edd5dc229dafae518febe2c095518b33dd9a2fb5c562b041eabcd8d9d1561d1ea27e138d526acfd9219105ab453bc9f1a7d01037e478fbc5621593e824871125ce0438743af0f8ba5bcc3c914e4e948413aedbc05bb88232c57f9133156ad1e54266ea9ac11f6e37c6a1d888ef57145a0bbf7e92c9f9345e95233d3563d6eaed85a733652af7fea5c148acdfbf632004e968e6fea614a6acf8c59b95940449a3988996cfa9fbc11155e44c69c2acaa9174f4e38a8f85d509ab289832232edac7206c9cfcdcb6612ccff6f5030e695fba6394800c3a662ed9768592cad9d40e40b20832a7a3e3a574b4df30b0499d8fdfe7a049e14093b07ac8bc215808b30f4f03c27118b5ee671e58f446f76e051ca03424336475f7a2c2b2312a20aa2ed68c461068dd523dab1d17a06684b3d39be0875a19406bd2877a8d47d8a7d7a1e0eb638249694a48140c19ffb4b80864bebaa598e0338edb23103e7ac110296a211d1339af3b35ab91e1b7bb56d704351158a02085c496520bc3174e47b96be57647499917e8da3067bf11ff3e1ad62b2f9f1df974b118f54cba56d9b450f12c7273025bf2f96d9909305ca32bc574d0e2128d3d1913a26b463e39537b57e7fff35ed46c5c78ea0253ce2bbd98fad68881c9042657b82b24929b85c727fa3c2ec68d71a7fcc415959c265ae2b62e5bc3f3d440b1402f2273febf47e7ec10459d46bd0b1512c01a49abe93f5b2178ff54885d82bac9364fe26b0d0530d73554e81afd11eb185fea0ac6f3474e50c4dec99cfa38fbb6a79b78843c078486200390a067798dcec55f20355a53755a9a8aa572fab0f580cad85ad520b02a0f4cbe4368574399498abf36544ce52d4b2daa3ba27fa9dc20a628f266cf96c54bbd7158ff1cfbf0fbc596bffa6c6c4835ee366137a5b358f91261630869910fd3d88f599d82594144c88a6919dbff5d6c26c4b2552b7c234d375140f7de49b5be2a343a108ba9f212461c954785153b2db0281ae2da9f8343cd5b0eacbec6bc079a6ebcb70954a325328f680c5bbcc26262803c423a84ce4695eff296b8945e22cca8f147f40eb6c1293e5d05d6ff0585f0c2183cb388ccaf288f6290ea6c164add90b0f28665be56f3ec020dec58e2e038ef83cfef7920dedae59f798aaf8a41b855eb66cc836036d347c975be18c442a5c83cd4f3bf433f0b04f7377309c1ff92b8205de8a072bd4afb9b15bc4c932204306638b3bccfaefcd09a0eb641bdec71f7b49ca4702ac4dc18b56277802d82e1226c38abb3738440c30398be2387b17e090d05ed99ac55d8d8eae1b41c324033eb7223bebbde09e3709fef0a02ee7eabfbb0bd82c83bc75723129d3d4d6c9ff9f871a6b2f9423f53f54a5455d98e783dc1a69e8392ede6ed18f15211445505e95e3745b1002614e9bc0b4c890e30473bc9e8988b4fc516710ef459d46537dc0adeb3ba5fa9d64afb5f22b302b909774144ac83cf7536c421095751f2b090070b0f691f1150b8628b0e8796f83c822e71dfd97bc1011fe3ea26e743ae99482dda5de2fe6880155d5083e21d9f5130b285274cecf235e43e28c0671492ae32dfeb99c5c2c53843e0e59d03f18998c9de421bcc4176af0d1108bab24142c4c5a30e0c100382ec69e4b0d8cf1270e3e5062c4422347112563a02e550b19f4b362471935b2a15215cd35c4a6f86a8f75266a46f8fde6d7b15686aaca229fd31d9e4cc66d4b6c724015ae9477f61f8b611ce3ab403952c86c0020800567eee7d396ef4d143e054e77d12ccbc060fa6e8f7fd3e1e660eab46ad6b30587ab3927a9e2df07ea04e649c93136b2b0e3dfe84492d437a58687c7188af832c6feed5fb77550424bcedb2f438e9ef1193104ef2b0e2c9da68e13fc0af52d58ca58b22cc606b94df7535e31f99e4384b43ed58e9eb9502e3b6bce15e6cd8c13ed74fd7622799cbdfa52bec6e89655a5c697249438db1d4e504e721928fde0500431cff790109cc658f194bd4d4f0722e12f51903914c9b0997c4cfa6aec480a466a2eace256ff2b271dafd99eaa6d99fbc4c86917dccc901606522938b2bb1cc1fcf2245a22c093261e4b3330655470b0c452f58e199b7d65704b38bca56d453d14edc946202060ff818ab790336274e9349b4811663f1fb8b19ac23fad080ec7efb9fa189dc3c4bf71e46bd5c4e769dd75acd5232e5004c01405ce4c7cc40ad43d6d20c0f69b778cd2c9b9761528c51e8c73d678c3ce0473977cfbc4e39c9dfbf7ae06a778b9c771e1db3de2864ef737946ef37462a80db124f3ad81b13b8fa89739dcc149ca70f7498494b6cb12e5a5b50c93c8ea85834c6f1a3ccf12270b39d60059def481f4c3722a12aa50a4e413a9e734762cc233c2e18b1deb37cef864daa50135e16a267f8b71f3c952466c3a110f7760fac6c7240b80acfedefbdae51367d642df08d34c6024c940a23d39f108ff67ee08dce712ea767233a132f8f484f66ef4c3ee174f74d64a9176844af54d56941cd1c66432848c1753d18bd0416d0f0150683f2d404869e2f56a521fc9c394d21e745803b4d7f5dea00aa158f6458db47743ce219cb46eacc01682a2ed32cdb7a6448abe2b5e032537507716ff5e5f6a2de8f7fb2a7b05ec715bfd51d5fce9ffacd86d0179aaa075a47e5bcca8a7c3d18906df366f1fab4d2dc8d4f575b7fd1350705d38976096c3662eb5b9568b20960d9b003a7abdafb5f1c63b6dda4f5bcf3c58e51fc7e9d4de8984dea45b8c3a306645fae4e2310d8aaa66978695c4644293fbd8b2246923515927fa8cb46524baab0d1b22011fb13efe88b5f51d2459d74de9ace9b0e20b9040313487c941d4e9c8ff361877f8514bad3dcb429683c19795c31bedf95dfe2d95a45cfa9bb26eb59778ca52efacf40f9ac31b802cd80efa25b486799e2f3b433eb3535d8e916748e6cddde0b47de4fdd047756ab8b1b1920200d7624bab0b7b4868faa36eacb923c657ff789afc61a64fea0db1e3a7222d0294db9fad1dd7c8badddf62679c30588bc11de67447929efe0921bd1ca4d3460140bc8c31d1d3bd0871f20adcb1dd0fdee60405ed1336b49e1f4f7c789fce209d4a45cdcb4b58f17486c18e2b29b882bccff9da1fb2aa0d","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"989dda761db921833469cd31358036ca"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
